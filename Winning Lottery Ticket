#include <iostream>
#include <vector>
#include <string>
#include <cmath>
#include <map>

/**
 * @brief Finds the number of winning pairs of distinct lottery tickets.
 * * A winning pair is one where the concatenation of their two ticket IDs 
 * contains all digits from 0 to 9 at least once.
 * * @param tickets A vector of strings, where each string is a ticket ID.
 * @return long long The total number of winning pairs.
 */
long long winningLotteryTicket(std::vector<std::string> tickets) {
    // A map to store the frequency of each unique digit-set (represented by a bitmask).
    // The mask is an integer where the i-th bit is set if digit i is present.
    // Since there are 10 digits (0-9), there are 2^10 = 1024 possible masks.
    std::vector<long long> mask_counts(1024, 0);

    // 1. Generate Bitmask for Each Ticket and Count Frequencies
    for (const std::string& ticket : tickets) {
        int mask = 0;
        for (char digit_char : ticket) {
            int digit = digit_char - '0';
            // Set the 'digit'-th bit. (1 << digit) shifts 1 to the left 'digit' times.
            mask |= (1 << digit);
        }
        mask_counts[mask]++;
    }

    // The target mask: all digits 0-9 present. 
    // This is 2^10 - 1 = 1023 (binary 1111111111).
    const int TARGET_MASK = 1023;
    
    long long winning_pairs = 0;

    // 2. Count Winning Pairs by Checking Combinations of Masks
    
    // Iterate through all possible mask1 (from 0 to 1023)
    for (int mask1 = 0; mask1 < 1024; ++mask1) {
        if (mask_counts[mask1] == 0) {
            continue; // Skip if no tickets have this mask
        }

        // Iterate through all possible mask2 (from mask1 to 1023) 
        // Starting from mask1 avoids double counting (mask1, mask2) and (mask2, mask1).
        for (int mask2 = mask1; mask2 < 1024; ++mask2) {
            if (mask_counts[mask2] == 0) {
                continue; // Skip if no tickets have this mask
            }
            
            // The combination of digits in two tickets is the bitwise OR of their masks.
            if ((mask1 | mask2) == TARGET_MASK) {
                // Winning scenario found.

                if (mask1 == mask2) {
                    // Case 1: Pairs from the SAME set of tickets (sharing mask1)
                    // We need to choose 2 distinct tickets from mask_counts[mask1] tickets.
                    // This is "n choose 2": n * (n - 1) / 2
                    long long n = mask_counts[mask1];
                    winning_pairs += n * (n - 1) / 2;
                } else {
                    // Case 2: Pairs from DIFFERENT sets of tickets (mask1 and mask2)
                    // Any ticket with mask1 can be paired with any ticket with mask2.
                    // The number of pairs is product of their counts.
                    winning_pairs += mask_counts[mask1] * mask_counts[mask2];
                }
            }
        }
    }

    return winning_pairs;
}

int main() {
    // Fast I/O
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    // Read the total number of lottery tickets
    if (!(std::cin >> n)) return 0;

    std::vector<std::string> tickets(n);
    // Read the ticket IDs
    for (int i = 0; i < n; ++i) {
        if (!(std::cin >> tickets[i])) return 0;
    }

    // Call the function and print the result
    long long result = winningLotteryTicket(tickets);
    std::cout << result << "\n";

    return 0;
}
